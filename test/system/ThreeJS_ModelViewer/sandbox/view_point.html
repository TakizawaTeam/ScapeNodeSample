<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
</head>
<body>
  <canvas id="myCanvas"></canvas>

  <script>
  function Point(x,y){ //座標(set/get, sum)
      this.x = x; this.y = y;
      this.setPoint=function(x,y){this.x = x;this.y = y;}
      this.getPoint=function(){return this;}
      this.sumPoint=function(point1){this.x+=point1.x; this.y+=point1.y;}
  }
  //1点の角度
  function rad(x,y){return rot_enc(Math.atan2(x,y)); };
  //2点の距離
  function disPoint(point1,point2){var distance=0;var distance=Math.sqrt(Math.pow(point2.x-point1.x,2)+Math.pow(point2.y-point1.y,2));return distance;}
  //2点の角度
  function radPoint(point1,point2){var rad;rad=Math.atan2(point1.y-point2.y,point1.x-point2.x);return rad;}
  //角度と距離から円周上の座標
  function disRotPoint(point1,distance,rotate){var rot_point=new Point(0,0);rot_point.x=point1.x+distance*Math.cos(rotate*Math.PI/180);rot_point.y=point1.y+distance*Math.sin(rotate*Math.PI/180);return rot_point;}
  //描画用のcanvas.context回転
  function drawRotate(_context,rad,point){_context.setTransform(Math.cos(rad),Math.sin(rad),-Math.sin(rad),Math.cos(rad),point.x,point.y);_context.translate(-1*point.x,-1*point.y);}
  //弧度法/度数法 変換
  function rad_enc(rot){return (rot*Math.PI/180);}
  function rot_enc(rad){return (rad*180/Math.PI);}


  const canvas = document.querySelector('#myCanvas');

  let moveX=0, moveY=0;
  canvas.addEventListener("click",function(e){ canvas.requestPointerLock(); });
  canvas.addEventListener("mousemove",function(e){
    if(document.pointerLockElement === canvas){
      moveX = e.movementX;
      moveY = e.movementY;
    }else{
      moveX = 0;
      moveY = 0;
    }
  });
  let keyflg = {};
  document.addEventListener("keydown",function(e){keyflg[e.keyCode]=true;});
  document.addEventListener("keyup",function(e){keyflg[e.keyCode]=false;});

  const config = {
    screen: {
      //size: {width: 480, height: 320},
      size: {width: 480, height: 320},
    },
  };
  let scene = null;
  let camera = null;
  let box = null;
  let sphere = null;
  let ground = null;
  let frame_counter = 0;
  const frame_log = (log, f=1)=>{
    if(frame_counter%f==0) console.log(log);
  };
  const FLAT = Math.sqrt(100);

  // オブジェクトからオブジェクトに移動させる
  const object_move = (obj, target, dis, rot=0)=>{
    p1 = new Point(obj.position.x, obj.position.z);
    p2 = new Point(target.position.x, target.position.z);
    rotate = rot_enc(radPoint(p2, p1));
    move_point = disRotPoint(p1, dis, rotate+rot);
    obj.position.x = move_point.x;
    obj.position.z = move_point.y;
  };

  /* INIT */
  function initialize(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, config.screen.size.width / config.screen.size.height);
    camera.position.set(0, FLAT, 100);

    let geometry = new THREE.BoxGeometry(10, 10, 10);
    let material = new THREE.MeshNormalMaterial();
    box = new THREE.Mesh(geometry, material);
    box.position.set(0, FLAT, 0);
    box.rotation.set(0, 0, 0);
    scene.add(box);

    geometry = new THREE.SphereGeometry(1, 1, 1);
    material = new THREE.MeshBasicMaterial( {color: 0x000000} );
    sphere = new THREE.Mesh( geometry, material );
    sphere.position.set(0, FLAT, 0);
    sphere.rotation.set(0, 0, 0);
    scene.add(sphere);

    geometry = new THREE.PlaneGeometry( 1000, 1000, 1000 );
    material = new THREE.MeshBasicMaterial( {color: 0xaaffaa, side: THREE.DoubleSide} );
    ground = new THREE.Mesh(geometry, material);
    ground.position.set(0, 0, 0);
    ground.rotation.set(rad_enc(90), 0, 0);
    scene.add(ground);

    var grid = new THREE.GridHelper(1000, 100, 0xff0000);
    scene.add(grid);
  }

  /* FRAME */
  function drawframe(render){
    frame_counter += 1;
    box.rotation.y += 0.01;
    box.rotation.x += 0.01;

    // カメラの角度
    if(moveX>10) moveX=10;
    if(moveY>10) moveY=10;
    //camera.rotation.y += moveX/100*-1;
    camera.rotation.y += moveX/100* (Math.abs(rot_enc(camera.rotation.x))>90? 1:-1);
    camera.rotation.x += moveY/100* (Math.abs(rot_enc(camera.rotation.y))>90? 1:-1); //xは上が0なので角度が反転する
    // カメラの縦の限界値(90,-90)
    if(rot_enc(camera.rotation.x) > 90) camera.rotation.x = rad_enc(90);
    if(rot_enc(camera.rotation.x) < -90) camera.rotation.x = rad_enc(-90);
    // カメラの縦の限界値(90,-90)
    //if(rot_enc(camera.rotation.y) > 360) camera.rotation.x = rad_enc(360);
    //if(rot_enc(camera.rotation.y) < -360) camera.rotation.x = rad_enc(-360);
    moveX = 0;
    moveY = 0;

    // カメラのカーソル及び移動処理
    cursor_distance = 50;
    camera_pos = new Point(camera.position.x, camera.position.z);
    cursor_rot = (360-rot_enc(camera.rotation.y)%360) - 90;
    cursor_movepos = disRotPoint(camera_pos, cursor_distance, cursor_rot);
    sphere.position.x = cursor_movepos.x;
    sphere.position.z = cursor_movepos.y;

    camera_speed = 1;
    if(keyflg[87] && !keyflg[83]) object_move(camera, sphere, camera_speed);
    if(keyflg[83] && !keyflg[87]) object_move(camera, sphere, camera_speed, 180);
    if(keyflg[65] && !keyflg[68]) object_move(camera, sphere, camera_speed, 90);
    if(keyflg[68] && !keyflg[65]) object_move(camera, sphere, camera_speed, -90);

    render.render(scene, camera); //描画
  }

  window.addEventListener('load', init);
  function init(){
    const render = new THREE.WebGLRenderer({canvas: canvas});
    render.setPixelRatio(window.devicePixelRatio);
    render.setSize(config.screen.size.width, config.screen.size.height);
    render.setClearColor(0xaaaaff, 1.0);

    initialize();
    frame();
    function frame(){
      drawframe(render);
      requestAnimationFrame(frame); //アニメーション処理実行
    }
  };
  </script>
</body>
